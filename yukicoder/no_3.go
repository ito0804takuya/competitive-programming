// 1からNの番号がふられている一直線に並べられているN個のマスがある。
// 1から開始のマスとして、ゴールはNが書かれているマスとする。

// その場に書かれている数字の2進数で表現した時の1のビット数 だけ「前」または「後」に進めることができる。
// (1未満とN+1以上のマスには移動することは出来ない、正確にNにならないとゴールできない）

// 自然数Nを与えられた時、ゴールに到達できる最短の移動数（開始のマスへも移動にカウントする）を求めてください。
// 到達できない場合は-1を出力してください。

// 開始のマスがすでにゴールになっている場合もあリます。

package main

import (
	"fmt"
	"strconv"
)

func main() {
	var n int64
	fmt.Scan(&n)
	fmt.Println(n)

	result := 1
	
	if n == 1 {
		fmt.Println(result)
		return
	}

	// 旧-------------------------
	// ゴールから、ゴール-1 の 2進数 桁数 分前の要素を調べる
	searchRange := len(strconv.FormatInt(n-1, 2))
	fmt.Println(searchRange)
		// その要素から、その位置のNの2進数の1のビット数分で、ゴールに到達できるのかを調べる
	// 到達できない場合は、次の要素に移る
	// 到達できる場合は、その要素をゴールとみなして、同じことを行う
	// 旧-------------------------

	// 新-------------------------
	// '1'がスタート地点
	// '1'がゴール地点かどうかを判定
	// '1'の1のビット数を取得
	// ビット数分、前に進むことができるか調べる
		// 前に進める場合、それがゴール地点かどうかを判定
			// ゴールじゃない場合は、その数が[ダメだったリスト]にあるか判定
				// なかった場合、その数を[あとで調べるリスト]に入れる。
				// あった場合、.....
		// 前に進めない場合（つまりゴールよりも大きい数値になってしまう場合、その数を[ダメだったリスト]に入れる。）
	// ビット数分、後ろに進むことができるか調べる
		// 後ろに進める場合、その数が[ダメだったリスト]にあるか判定
			// 無かった場合、その数を[あとで調べるリスト]に入れる。
			// あった場合、.....
		// 後ろに進めない場合（つまり'1'以下になってしまう場合）、.....
	
}